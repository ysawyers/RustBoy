use crate::internal::core::component::{MicroInstr, CPU};
use crate::internal::core::registers::Register;

impl CPU {
    pub fn decode_prefix_instr(&self, opcode: u8) -> Vec<MicroInstr> {
        match opcode {
            0x00 => vec![MicroInstr::RLCR(Register::B)], // RLC B
            0x01 => vec![MicroInstr::RLCR(Register::C)], // RLC C
            0x02 => vec![MicroInstr::RLCR(Register::D)], // RLC D
            0x03 => vec![MicroInstr::RLCR(Register::E)], // RLC E
            0x04 => vec![MicroInstr::RLCR(Register::H)], // RLC H
            0x05 => vec![MicroInstr::RLCR(Register::L)], // RLC L
            0x06 => vec![MicroInstr::NOP, MicroInstr::NOP, MicroInstr::RLCHL], // RLC (HL)
            0x07 => vec![MicroInstr::RLCR(Register::A)], // RLC A

            0x08 => vec![MicroInstr::RRCR(Register::B)], // RRC B
            0x09 => vec![MicroInstr::RRCR(Register::C)], // RRC C
            0x0A => vec![MicroInstr::RRCR(Register::D)], // RRC D
            0x0B => vec![MicroInstr::RRCR(Register::E)], // RRC E
            0x0C => vec![MicroInstr::RRCR(Register::H)], // RRC H
            0x0D => vec![MicroInstr::RRCR(Register::L)], // RRC L
            0x0E => vec![MicroInstr::NOP, MicroInstr::NOP, MicroInstr::RRCHL], // RRC (HL)
            0x0F => vec![MicroInstr::RRCR(Register::A)], // RRC A

            0x10 => vec![MicroInstr::RLR(Register::B)], // RL B
            0x11 => vec![MicroInstr::RLR(Register::C)], // RL C
            0x12 => vec![MicroInstr::RLR(Register::D)], // RL D
            0x13 => vec![MicroInstr::RLR(Register::E)], // RL E
            0x14 => vec![MicroInstr::RLR(Register::H)], // RL H
            0x15 => vec![MicroInstr::RLR(Register::L)], // RL L
            0x16 => vec![MicroInstr::NOP, MicroInstr::NOP, MicroInstr::RLHL], // RL (HL)
            0x17 => vec![MicroInstr::RLR(Register::A)], // RL A

            0x18 => vec![MicroInstr::RRR(Register::B)], // RR B
            0x19 => vec![MicroInstr::RRR(Register::C)], // RR C
            0x1A => vec![MicroInstr::RRR(Register::D)], // RR D
            0x1B => vec![MicroInstr::RRR(Register::E)], // RR E
            0x1C => vec![MicroInstr::RRR(Register::H)], // RR H
            0x1D => vec![MicroInstr::RRR(Register::L)], // RR L
            0x1E => vec![MicroInstr::NOP, MicroInstr::NOP, MicroInstr::RRHL], // RR (HL)
            0x1F => vec![MicroInstr::RRR(Register::A)], // RR A
            
            0x20 => vec![MicroInstr::SLAR(Register::B)], // SLA B
            0x21 => vec![MicroInstr::SLAR(Register::C)], // SLA C
            0x22 => vec![MicroInstr::SLAR(Register::D)], // SLA D
            0x23 => vec![MicroInstr::SLAR(Register::E)], // SLA E
            0x24 => vec![MicroInstr::SLAR(Register::H)], // SLA H
            0x25 => vec![MicroInstr::SLAR(Register::L)], // SLA L
            0x26 => vec![MicroInstr::NOP, MicroInstr::NOP, MicroInstr::SLAHL], // SLA (HL)
            0x27 => vec![MicroInstr::SLAR(Register::A)], // SLA A

            0x28 => vec![MicroInstr::SRAR(Register::B)], // SRA B
            0x29 => vec![MicroInstr::SRAR(Register::C)], // SRA C
            0x2A => vec![MicroInstr::SRAR(Register::D)], // SRA D
            0x2B => vec![MicroInstr::SRAR(Register::E)], // SRA E
            0x2C => vec![MicroInstr::SRAR(Register::H)], // SRA H
            0x2D => vec![MicroInstr::SRAR(Register::L)], // SRA L
            0x2E => vec![MicroInstr::NOP, MicroInstr::NOP, MicroInstr::SRAHL], // SRA (HL)
            0x2F => vec![MicroInstr::SRAR(Register::A)], // SRA A

            0x30 => vec![MicroInstr::SWAP(Register::B)], // SWAP B
            0x31 => vec![MicroInstr::SWAP(Register::C)], // SWAP C
            0x32 => vec![MicroInstr::SWAP(Register::D)], // SWAP D
            0x33 => vec![MicroInstr::SWAP(Register::E)], // SWAP E
            0x34 => vec![MicroInstr::SWAP(Register::H)], // SWAP H
            0x35 => vec![MicroInstr::SWAP(Register::L)], // SWAP L
            0x36 => vec![MicroInstr::NOP, MicroInstr::NOP, MicroInstr::SWAPHL], // SWAP (HL)
            0x37 => vec![MicroInstr::SWAP(Register::A)], // SWAP A

            0x38 => vec![MicroInstr::SRLR(Register::B)], // SRL B
            0x39 => vec![MicroInstr::SRLR(Register::C)], // SRL C
            0x3A => vec![MicroInstr::SRLR(Register::D)], // SRL D
            0x3B => vec![MicroInstr::SRLR(Register::E)], // SRL E
            0x3C => vec![MicroInstr::SRLR(Register::H)], // SRL H
            0x3D => vec![MicroInstr::SRLR(Register::L)], // SRL L
            0x3E => vec![MicroInstr::NOP, MicroInstr::NOP, MicroInstr::SRLHL], // SRL (HL)
            0x3F => vec![MicroInstr::SRLR(Register::A)], // SRL A
            
            0x40 => vec![MicroInstr::BIT(0, Register::B)], // BIT 0, B
            0x41 => vec![MicroInstr::BIT(0, Register::C)], // BIT 0, C
            0x42 => vec![MicroInstr::BIT(0, Register::D)], // BIT 0, D
            0x43 => vec![MicroInstr::BIT(0, Register::E)], // BIT 0, E
            0x44 => vec![MicroInstr::BIT(0, Register::H)], // BIT 0, H
            0x45 => vec![MicroInstr::BIT(0, Register::L)], // BIT 0, L
            0x46 => vec![MicroInstr::NOP, MicroInstr::BITHL(0)], // BIT 0, (HL)
            0x47 => vec![MicroInstr::BIT(0, Register::A)], // BIT 0, B
            0x48 => vec![MicroInstr::BIT(1, Register::B)], // BIT 1, B
            0x49 => vec![MicroInstr::BIT(1, Register::C)], // BIT 1, C
            0x4A => vec![MicroInstr::BIT(1, Register::D)], // BIT 1, D
            0x4B => vec![MicroInstr::BIT(1, Register::E)], // BIT 1, E
            0x4C => vec![MicroInstr::BIT(1, Register::H)], // BIT 1, H
            0x4D => vec![MicroInstr::BIT(1, Register::L)], // BIT 1, L
            0x4E => vec![MicroInstr::NOP, MicroInstr::BITHL(1)], // BIT 1, (HL)
            0x4F => vec![MicroInstr::BIT(1, Register::A)], // BIT 1, A
            0x50 => vec![MicroInstr::BIT(2, Register::B)], // BIT 2, B
            0x51 => vec![MicroInstr::BIT(2, Register::C)], // BIT 2, C
            0x52 => vec![MicroInstr::BIT(2, Register::D)], // BIT 2, D
            0x53 => vec![MicroInstr::BIT(2, Register::E)], // BIT 2, E
            0x54 => vec![MicroInstr::BIT(2, Register::H)], // BIT 2, H
            0x55 => vec![MicroInstr::BIT(2, Register::L)], // BIT 2, L
            0x56 => vec![MicroInstr::NOP, MicroInstr::BITHL(2)], // BIT 2, (HL)
            0x57 => vec![MicroInstr::BIT(2, Register::A)], // BIT 2, A
            0x58 => vec![MicroInstr::BIT(3, Register::B)], // BIT 3, B
            0x59 => vec![MicroInstr::BIT(3, Register::C)], // BIT 3, C
            0x5A => vec![MicroInstr::BIT(3, Register::D)], // BIT 3, D
            0x5B => vec![MicroInstr::BIT(3, Register::E)], // BIT 3, E
            0x5C => vec![MicroInstr::BIT(3, Register::H)], // BIT 3, H
            0x5D => vec![MicroInstr::BIT(3, Register::L)], // BIT 3, L
            0x5E => vec![MicroInstr::NOP, MicroInstr::BITHL(3)], // BIT 3, (HL)
            0x5F => vec![MicroInstr::BIT(3, Register::A)], // BIT 3, A
            0x60 => vec![MicroInstr::BIT(4, Register::B)], // BIT 4, B
            0x61 => vec![MicroInstr::BIT(4, Register::C)], // BIT 4, C
            0x62 => vec![MicroInstr::BIT(4, Register::D)], // BIT 4, D
            0x63 => vec![MicroInstr::BIT(4, Register::E)], // BIT 4, E
            0x64 => vec![MicroInstr::BIT(4, Register::H)], // BIT 4, H
            0x65 => vec![MicroInstr::BIT(4, Register::L)], // BIT 4, L
            0x66 => vec![MicroInstr::NOP, MicroInstr::BITHL(4)], // BIT 4, (HL)
            0x67 => vec![MicroInstr::BIT(4, Register::A)], // BIT 4, A
            0x68 => vec![MicroInstr::BIT(5, Register::B)], // BIT 5, B
            0x69 => vec![MicroInstr::BIT(5, Register::C)], // BIT 5, C
            0x6A => vec![MicroInstr::BIT(5, Register::D)], // BIT 5, D
            0x6B => vec![MicroInstr::BIT(5, Register::E)], // BIT 5, E
            0x6C => vec![MicroInstr::BIT(5, Register::H)], // BIT 5, H
            0x6D => vec![MicroInstr::BIT(5, Register::L)], // BIT 5, L
            0x6E => vec![MicroInstr::NOP, MicroInstr::BITHL(5)], // BIT 5, (HL)
            0x6F => vec![MicroInstr::BIT(5, Register::A)], // BIT 5, A
            0x70 => vec![MicroInstr::BIT(6, Register::B)], // BIT 6, B
            0x71 => vec![MicroInstr::BIT(6, Register::C)], // BIT 6, C
            0x72 => vec![MicroInstr::BIT(6, Register::D)], // BIT 6, D
            0x73 => vec![MicroInstr::BIT(6, Register::E)], // BIT 6, E
            0x74 => vec![MicroInstr::BIT(6, Register::H)], // BIT 6, H
            0x75 => vec![MicroInstr::BIT(6, Register::L)], // BIT 6, L
            0x76 => vec![MicroInstr::NOP, MicroInstr::BITHL(6)], // BIT 6, (HL)
            0x77 => vec![MicroInstr::BIT(6, Register::A)], // BIT 6, A
            0x78 => vec![MicroInstr::BIT(7, Register::B)], // BIT 7, B
            0x79 => vec![MicroInstr::BIT(7, Register::C)], // BIT 7, C
            0x7A => vec![MicroInstr::BIT(7, Register::D)], // BIT 7, D
            0x7B => vec![MicroInstr::BIT(7, Register::E)], // BIT 7, E
            0x7C => vec![MicroInstr::BIT(7, Register::H)], // BIT 7, H
            0x7D => vec![MicroInstr::BIT(7, Register::L)], // BIT 7, L
            0x7E => vec![MicroInstr::NOP, MicroInstr::BITHL(7)], // BIT 7, (HL)
            0x7F => vec![MicroInstr::BIT(7, Register::A)], // BIT 7, A

            0x80 => vec![MicroInstr::RES(0, Register::B)], // RES 0, B
            0x81 => vec![MicroInstr::RES(0, Register::C)], // RES 0, C
            0x82 => vec![MicroInstr::RES(0, Register::D)], // RES 0, D
            0x83 => vec![MicroInstr::RES(0, Register::E)], // RES 0, E
            0x84 => vec![MicroInstr::RES(0, Register::H)], // RES 0, H
            0x85 => vec![MicroInstr::RES(0, Register::L)], // RES 0, L
            0x86 => vec![MicroInstr::NOP, MicroInstr::NOP, MicroInstr::RESHL(0)], // RES 0, (HL)
            0x87 => vec![MicroInstr::RES(0, Register::A)], // RES 0, A
            0x88 => vec![MicroInstr::RES(1, Register::B)], // RES 1, B
            0x89 => vec![MicroInstr::RES(1, Register::C)], // RES 1, C
            0x8A => vec![MicroInstr::RES(1, Register::D)], // RES 1, D
            0x8B => vec![MicroInstr::RES(1, Register::E)], // RES 1, E
            0x8C => vec![MicroInstr::RES(1, Register::H)], // RES 1, H
            0x8D => vec![MicroInstr::RES(1, Register::L)], // RES 1, L
            0x8E => vec![MicroInstr::NOP, MicroInstr::NOP, MicroInstr::RESHL(1)], // RES 1, (HL)
            0x8F => vec![MicroInstr::RES(1, Register::A)], // RES 1, A
            0x90 => vec![MicroInstr::RES(2, Register::B)], // RES 2, B
            0x91 => vec![MicroInstr::RES(2, Register::C)], // RES 2, C
            0x92 => vec![MicroInstr::RES(2, Register::D)], // RES 2, D
            0x93 => vec![MicroInstr::RES(2, Register::E)], // RES 2, E
            0x94 => vec![MicroInstr::RES(2, Register::H)], // RES 2, H
            0x95 => vec![MicroInstr::RES(2, Register::L)], // RES 2, L
            0x96 => vec![MicroInstr::NOP, MicroInstr::NOP, MicroInstr::RESHL(2)], // RES 2, (HL)
            0x97 => vec![MicroInstr::RES(2, Register::A)], // RES 2, A
            0x98 => vec![MicroInstr::RES(3, Register::B)], // RES 3, B
            0x99 => vec![MicroInstr::RES(3, Register::C)], // RES 3, C
            0x9A => vec![MicroInstr::RES(3, Register::D)], // RES 3, D
            0x9B => vec![MicroInstr::RES(3, Register::E)], // RES 3, E
            0x9C => vec![MicroInstr::RES(3, Register::H)], // RES 3, H
            0x9D => vec![MicroInstr::RES(3, Register::L)], // RES 3, L
            0x9E => vec![MicroInstr::NOP, MicroInstr::NOP, MicroInstr::RESHL(3)], // RES 3, (HL)
            0x9F => vec![MicroInstr::RES(3, Register::A)], // RES 3, A
            0xA0 => vec![MicroInstr::RES(4, Register::B)], // RES 4, B
            0xA1 => vec![MicroInstr::RES(4, Register::C)], // RES 4, C
            0xA2 => vec![MicroInstr::RES(4, Register::D)], // RES 4, D
            0xA3 => vec![MicroInstr::RES(4, Register::E)], // RES 4, E
            0xA4 => vec![MicroInstr::RES(4, Register::H)], // RES 4, H
            0xA5 => vec![MicroInstr::RES(4, Register::L)], // RES 4, L
            0xA6 => vec![MicroInstr::NOP, MicroInstr::NOP, MicroInstr::RESHL(4)], // RES 4, (HL)
            0xA7 => vec![MicroInstr::RES(4, Register::A)], // RES 4, A
            0xA8 => vec![MicroInstr::RES(5, Register::B)], // RES 5, B
            0xA9 => vec![MicroInstr::RES(5, Register::C)], // RES 5, C
            0xAA => vec![MicroInstr::RES(5, Register::D)], // RES 5, D
            0xAB => vec![MicroInstr::RES(5, Register::E)], // RES 5, E
            0xAC => vec![MicroInstr::RES(5, Register::H)], // RES 5, H
            0xAD => vec![MicroInstr::RES(5, Register::L)], // RES 5, L
            0xAE => vec![MicroInstr::NOP, MicroInstr::NOP, MicroInstr::RESHL(5)], // RES 5, (HL)
            0xAF => vec![MicroInstr::RES(5, Register::A)], // RES 5, A
            0xB0 => vec![MicroInstr::RES(6, Register::B)], // RES 6, B
            0xB1 => vec![MicroInstr::RES(6, Register::C)], // RES 6, C
            0xB2 => vec![MicroInstr::RES(6, Register::D)], // RES 6, D
            0xB3 => vec![MicroInstr::RES(6, Register::E)], // RES 6, E
            0xB4 => vec![MicroInstr::RES(6, Register::H)], // RES 6, H
            0xB5 => vec![MicroInstr::RES(6, Register::L)], // RES 6, L
            0xB6 => vec![MicroInstr::NOP, MicroInstr::NOP, MicroInstr::RESHL(6)], // RES 6, (HL)
            0xB7 => vec![MicroInstr::RES(6, Register::A)], // RES 6, A
            0xB8 => vec![MicroInstr::RES(7, Register::B)], // RES 7, B
            0xB9 => vec![MicroInstr::RES(7, Register::C)], // RES 7, C
            0xBA => vec![MicroInstr::RES(7, Register::D)], // RES 7, D
            0xBB => vec![MicroInstr::RES(7, Register::E)], // RES 7, E
            0xBC => vec![MicroInstr::RES(7, Register::H)], // RES 7, H
            0xBD => vec![MicroInstr::RES(7, Register::L)], // RES 7, L
            0xBE => vec![MicroInstr::NOP, MicroInstr::NOP, MicroInstr::RESHL(7)], // RES 7, (HL)
            0xBF => vec![MicroInstr::RES(7, Register::A)], // RES 7, A

            0xC0 => vec![MicroInstr::SET(0, Register::B)], // SET 0, B
            0xC1 => vec![MicroInstr::SET(0, Register::C)], // SET 0, C
            0xC2 => vec![MicroInstr::SET(0, Register::D)], // SET 0, D
            0xC3 => vec![MicroInstr::SET(0, Register::E)], // SET 0, E
            0xC4 => vec![MicroInstr::SET(0, Register::H)], // SET 0, H
            0xC5 => vec![MicroInstr::SET(0, Register::L)], // SET 0, L
            0xC6 => vec![MicroInstr::NOP, MicroInstr::NOP, MicroInstr::SETHL(0)], // SET 0, (HL)
            0xC7 => vec![MicroInstr::SET(0, Register::A)], // SET 0, A
            0xC8 => vec![MicroInstr::SET(1, Register::B)], // SET 1, B
            0xC9 => vec![MicroInstr::SET(1, Register::C)], // SET 1, C
            0xCA => vec![MicroInstr::SET(1, Register::D)], // SET 1, D
            0xCB => vec![MicroInstr::SET(1, Register::E)], // SET 1, E
            0xCC => vec![MicroInstr::SET(1, Register::H)], // SET 1, H
            0xCD => vec![MicroInstr::SET(1, Register::L)], // SET 1, L
            0xCE => vec![MicroInstr::NOP, MicroInstr::NOP, MicroInstr::SETHL(1)], // SET 1, (HL)
            0xCF => vec![MicroInstr::SET(1, Register::A)], // SET 1, A
            0xD0 => vec![MicroInstr::SET(2, Register::B)], // SET 2, B
            0xD1 => vec![MicroInstr::SET(2, Register::C)], // SET 2, C
            0xD2 => vec![MicroInstr::SET(2, Register::D)], // SET 2, D
            0xD3 => vec![MicroInstr::SET(2, Register::E)], // SET 2, E
            0xD4 => vec![MicroInstr::SET(2, Register::H)], // SET 2, H
            0xD5 => vec![MicroInstr::SET(2, Register::L)], // SET 2, L
            0xD6 => vec![MicroInstr::NOP, MicroInstr::NOP, MicroInstr::SETHL(2)], // SET 2, (HL)
            0xD7 => vec![MicroInstr::SET(2, Register::A)], // SET 2, A
            0xD8 => vec![MicroInstr::SET(3, Register::B)], // SET 3, B
            0xD9 => vec![MicroInstr::SET(3, Register::C)], // SET 3, C
            0xDA => vec![MicroInstr::SET(3, Register::D)], // SET 3, D
            0xDB => vec![MicroInstr::SET(3, Register::E)], // SET 3, E
            0xDC => vec![MicroInstr::SET(3, Register::H)], // SET 3, H
            0xDD => vec![MicroInstr::SET(3, Register::L)], // SET 3, L
            0xDE => vec![MicroInstr::NOP, MicroInstr::NOP, MicroInstr::SETHL(3)], // SET 3, (HL)
            0xDF => vec![MicroInstr::SET(3, Register::A)], // SET 3, A
            0xE0 => vec![MicroInstr::SET(4, Register::B)], // SET 4, B
            0xE1 => vec![MicroInstr::SET(4, Register::C)], // SET 4, C
            0xE2 => vec![MicroInstr::SET(4, Register::D)], // SET 4, D
            0xE3 => vec![MicroInstr::SET(4, Register::E)], // SET 4, E
            0xE4 => vec![MicroInstr::SET(4, Register::H)], // SET 4, H
            0xE5 => vec![MicroInstr::SET(4, Register::L)], // SET 4, L
            0xE6 => vec![MicroInstr::NOP, MicroInstr::NOP, MicroInstr::SETHL(4)], // SET 4, (HL)
            0xE7 => vec![MicroInstr::SET(4, Register::A)], // SET 4, A
            0xE8 => vec![MicroInstr::SET(5, Register::B)], // SET 5, B
            0xE9 => vec![MicroInstr::SET(5, Register::C)], // SET 5, C
            0xEA => vec![MicroInstr::SET(5, Register::D)], // SET 5, D
            0xEB => vec![MicroInstr::SET(5, Register::E)], // SET 5, E
            0xEC => vec![MicroInstr::SET(5, Register::H)], // SET 5, H
            0xED => vec![MicroInstr::SET(5, Register::L)], // SET 5, L
            0xEE => vec![MicroInstr::NOP, MicroInstr::NOP, MicroInstr::SETHL(5)], // SET 5, (HL)
            0xEF => vec![MicroInstr::SET(5, Register::A)], // SET 5, A
            0xF0 => vec![MicroInstr::SET(6, Register::B)], // SET 6, B
            0xF1 => vec![MicroInstr::SET(6, Register::C)], // SET 6, C
            0xF2 => vec![MicroInstr::SET(6, Register::D)], // SET 6, D
            0xF3 => vec![MicroInstr::SET(6, Register::E)], // SET 6, E
            0xF4 => vec![MicroInstr::SET(6, Register::H)], // SET 6, H
            0xF5 => vec![MicroInstr::SET(6, Register::L)], // SET 6, L
            0xF6 => vec![MicroInstr::NOP, MicroInstr::NOP, MicroInstr::SETHL(6)], // SET 6, (HL)
            0xF7 => vec![MicroInstr::SET(6, Register::A)], // SET 6, A
            0xF8 => vec![MicroInstr::SET(7, Register::B)], // SET 7, B
            0xF9 => vec![MicroInstr::SET(7, Register::C)], // SET 7, C
            0xFA => vec![MicroInstr::SET(7, Register::D)], // SET 7, D
            0xFB => vec![MicroInstr::SET(7, Register::E)], // SET 7, E
            0xFC => vec![MicroInstr::SET(7, Register::H)], // SET 7, H
            0xFD => vec![MicroInstr::SET(7, Register::L)], // SET 7, L
            0xFE => vec![MicroInstr::NOP, MicroInstr::NOP, MicroInstr::SETHL(7)], // SET 7, (HL)
            0xFF => vec![MicroInstr::SET(7, Register::A)], // SET 7, A
        }
    }
}